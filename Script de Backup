#!/bin/bash

######### script de backup das pastas importantes do usuário jacknpoe (+ páginas em htdocs) #########

# essa função faz echo e log ao mesmo tempo
d_echo() {
    local mensagem=$1

    # echo no terminal
    echo "$mensagem"

    # log no arquivo
    echo "$mensagem" >> "$log_arquivo"
}

# essa função resume muita coisa para facilitar a cópia de pastas
copia() {
    local origem=$1

    # guarda o tempo inicial para cálculo da duração da cópia
    tempo_ini_cp=$SECONDS

    # incrementa o número da cópia atual
    copia_atual=$((copia_atual + 1))

    # separa somente o nome da pasta, ignorando o caminho
    pasta=$(basename "$origem")

    # informa o início da cópia
    d_echo "$copia_atual: copiando de \"$pasta\"..."

    # faz a cópia com rsync, sem links simbólicos
    rsync -a --no-links "$origem" "$caminho_pasta" > /dev/null

    # esses espaços servem para alinhar a saída do script, dependendo do número da cópia atual
    digitos=${#copia_atual}
    tamanho=$(($digitos + 2))
    espacos=$(printf "%0.s " $(seq 1 $tamanho))

    # Verifica o código de saída do comando rsync e atualiza os contadores de sucesso e falha
    if [ $? -eq 0 ]; then
        sucessos=$((sucessos + 1))
        d_echo "$espacos(cópia de \"$pasta\" concluída com sucesso)"
    else
        falhas=$((falhas + 1))
        d_echo "$espacos(falha na cópia de \"$pasta\")"
    fi

    # calcula o tempo decorrido da cópia e informa
    tempo_dec_cp=$((SECONDS - tempo_ini_cp))
    d_echo "$espacos(tempo: $((tempo_dec_cp / 60)) minutos e $((tempo_dec_cp % 60)) segundos)" && d_echo
}

# pega o nome da pasta do argumento, se houver
nome_da_pasta=$1

# se faltar o nome da pasta como argumento, pede ao usuário
if [[ -z "$nome_da_pasta" ]]; then
    # pede o nome da pasta, senão será backup_AAAA_MM_DD_HH_MM_SS
    read -p "Nome da pasta do backup (nada para 'backup_AAAA_MM_DD_HH_MM_SS'): " nome_da_pasta
fi

# essas pastas são as maiores entre as candidatas a backup, que deve ser feito eventualmente
# veja que não espera teclar enter, apenas teclar s ou outra tecla já continua
read -n 1 -r -p "Copiar também 'do dropbox'? (s/n): " r_dropbox
echo

read -n 1 -r -p "Copiar também 'Linguagens'? (s/n): " r_linguagens
echo

read -n 1 -r -p "Copiar também 'Músicas'? (s/n): " r_musicas
echo && echo

# guarda o tempo inicial para cálculo de duração do backup
tempo_inicial=$SECONDS

# variável para encontrar qual é o número da pasta em copia()
copia_atual=0

# variáveis que guardam sucessos e falhas
sucessos=0
falhas=0

# se o nome da pasta estiver vazio, cria um nome padrão backup_AAAA_MM_DD_HH_MM_SS
if [[ -z "$nome_da_pasta" ]]; then
    data_atual=$(date +'%Y_%m_%d_%H_%M_%S')
    nome_da_pasta="backup_$data_atual"
fi
echo "Iniciando backup em: \"$nome_da_pasta\""

# monta o nome completo do caminha da pasta, para echo, criação de diretório e cópias
caminho_pasta="/media/jacknpoe/115GB/$nome_da_pasta"

# cria a pasta de backup
echo "Criando pasta de backup em: \"$caminho_pasta\"" && echo
mkdir -p "$caminho_pasta"

# nome e caminho do arquivo de log do backup
log_arquivo="$caminho_pasta/backup_log.txt"

# cabeçalho do arquivo de log
echo "-------------------------------------------------------" >> "$log_arquivo"
echo "Log do backup iniciado em: $(date)" >> "$log_arquivo"
echo "-------------------------------------------------------" >> "$log_arquivo" && echo >> "$log_arquivo"

###################### as cópias em si ##########################

copia "/home/jacknpoe/Documentos"

if [[ "$r_dropbox" == "s" ]]; then
    copia "/home/jacknpoe/do dropbox"
fi

copia "/home/jacknpoe/DOS"

copia "/home/jacknpoe/DownsWin"

copia "/home/jacknpoe/Vídeos/Gravações de tela"

copia "/opt/lampp/htdocs"

copia "/home/jacknpoe/Imagens"

copia "/home/jacknpoe/Juros"

if [[ "$r_linguagens" == "s" ]]; then
    copia "/home/jacknpoe/Linguagens"
fi

copia "/home/jacknpoe/Vídeos/locais"

if [[ "$r_musicas" == "s" ]]; then
    copia "/home/jacknpoe/Músicas"
fi

copia "/home/jacknpoe/Executáveis/scripts"

#################################################################

# calcula o tempo final e a duração do backup e mostra o tempo decorrido
tempo_decorrido=$((SECONDS - tempo_inicial))
d_echo "Tempo de execução: $((tempo_decorrido / 60)) minutos e $((tempo_decorrido % 60)) segundos."

# mostra o resumo final de sucessos e falhas
d_echo "Backup finalizado com $sucessos cópias bem-sucedidas e $falhas falhas."
echo >> "$log_arquivo"

# retorna 0 se não houve falhas, ou mais de 0 se houve falhas
exit $falhas
